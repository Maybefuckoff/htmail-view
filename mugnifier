#!/usr/bin/perl

# mugnifier - (mutt) offline mailcap viewer
#
# Authors:
#   Thomas Liske <thomas@fiasko-nw.net>
#
# Copyright Holder:
#   2015 (C) Thomas Liske [http://fiasko-nw.net/~thomas/]
#
# License:
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this package; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#

use Browser::Open qw(open_browser);
use Glib::Object::Introspection;
use URI;

use warnings;
use strict;


# gir initialization
Glib::Object::Introspection->setup(
    basename => 'Gtk',
    version => '3.0',
    package => 'Gtk3');

Glib::Object::Introspection->setup(
    basename => 'WebKit',
    version => '3.0',
    package => 'WebKit');


# GUI initialization
Gtk3::init(\@ARGV);
my $window = Gtk3::Window->new('toplevel');
my $box = Gtk3::Box->new('GTK_ORIENTATION_VERTICAL', 0);

my $scrolls = Gtk3::ScrolledWindow->new;
my $view = WebKit::WebView->new;
$scrolls->add($view);


my $toolbar = Gtk3::Toolbar->new;

my $btn_permit = Gtk3::ToolButton->new;
$btn_permit->set_label("Allow...");
$btn_permit->set_icon_name('gtk-dialog-error');

my $btn_open = Gtk3::ToolButton->new;
$btn_open->set_label("Browser");
$btn_open->set_icon_name('gtk-dnd');

my $btn_close = Gtk3::ToolButton->new;
$btn_close->set_label("Close");
$btn_close->set_icon_name('gtk-quit');

$toolbar->insert($btn_close, 0);
$toolbar->insert((Gtk3::SeparatorToolItem->new), 1);
$toolbar->insert($btn_permit, 2);
$toolbar->insert($btn_open, 3);


$window->set_default_size(762, 724);
$box->pack_start($toolbar, 0, 0, 0);
$box->pack_start($scrolls, 1, 1, 0);
$window->add($box);
$window->show_all;
$window->signal_connect(destroy => sub { Gtk3->main_quit });


# URI handling
my $uri = URI->new(shift);
my $uri_hp = eval { $uri->host_port; };
my %allowed;
$allowed{$uri_hp}++ if($uri_hp);

unless($uri->has_recognized_scheme) {
    print STDERR "ERROR: missing or unsupported scheme in URI!\n";
    exit 1;
}

# check if a request should pass
sub check_request {
    my $req = shift;
    my $req_hp = eval { $req->host_port; };

    # requests of the original URI should always pass
    return 1 if($uri->eq($req));

    # allow whitelist
    return $allowed{$req_hp} if($req_hp);

    # deny any any
    return 0;
}

# intercept any resource requests
$view->signal_connect('resource-request-starting' => sub {
    my ($view, $frame, $resource, $request, $response) = @_;

    my $requri = URI->new($request->get_uri, $uri->scheme);
    if(check_request($requri)) {
#	print STDERR "ALLOWED: ".$request->get_uri."\n";
	return;
    }

#    print STDERR "DENIED: ".$request->get_uri."\n";
    $request->set_uri('about:blank');
});

sub check_navpol {
    my $req = shift;
    my $req_hp = eval { $req->host_port; };

    # requests of the original URI should always pass
    return 1 if($uri->eq($req));

    # any else should launch the external browser
    return 0;
}

$view->signal_connect('navigation-policy-decision-requested' => sub {
    my ($view, $frame, $request, $action, $decision) = @_;

    my $requri = URI->new($request->get_uri, $uri->scheme);
    return 0 if(check_navpol($requri));

    # launch external browser
    open_browser($request->get_uri);
    
    $decision->ignore;
    return 1;
});

# load initial site
$view->load_uri($uri->as_string);

# main loop
Gtk3->main;
